<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sim3Colts // Holographic Online Arena</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        /* Pure pixel aesthetic, no blurry anti-aliasing */
        canvas {
            image-rendering: pixelated;
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #boot-seq {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.9);
            color: #00ffcc;
            font-family: monospace;
            cursor: pointer;
            z-index: 50;
            transition: opacity 1s;
        }
        .pulse { animation: p 1.5s infinite; }
        @keyframes p { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div id="boot-seq">
        <h1 style="font-size: 2rem; letter-spacing: 0.5em; text-shadow: 0 0 10px #00ffcc;">SIM3COLTS</h1>
        <p class="pulse">CONNECTING TO ONLINE ARENA...</p>
        <p style="font-size: 0.7rem; color: #ff00aa; margin-top: 20px;">[ CLICK TO ENGAGE AUDIO SENSORS ]</p>
    </div>

    <!-- Pure Computational Canvas -->
    <canvas id="sim-canvas"></canvas>

    <script>
        // --- Core Architectural Constants ---
        const TARGET_PIXELS = 25600; 
        const BOUNDARY_RADIUS = 0.85; 
        const MATCH_DURATION = 60; 

        // --- Hardware Buffer Setup ---
        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d');
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        
        let GRID_W = 100;
        let GRID_H = 100;
        let imgData, buf;

        function resize() {
            const w = Math.max(1, window.innerWidth || 800);
            const h = Math.max(1, window.innerHeight || 600);
            canvas.width = w;
            canvas.height = h;
            ctx.imageSmoothingEnabled = false;

            const aspect = w / h;
            GRID_H = Math.max(1, Math.floor(Math.sqrt(TARGET_PIXELS / aspect)));
            GRID_W = Math.max(1, Math.floor(GRID_H * aspect));

            offCanvas.width = GRID_W;
            offCanvas.height = GRID_H;
            imgData = offCtx.createImageData(GRID_W, GRID_H);
            buf = new Uint32Array(imgData.data.buffer);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- State ---
        let gameState = 'BOOT'; 
        let geoMode = 2; // Default: MORPH
        let gameRule = 0; // Default: SINK
        let visMode = 0; // 0 = NORM, 1 = ILLUS
        
        let globalTime = 0;
        let matchStartTime = 0;
        let timeRemaining = MATCH_DURATION;
        let p1Score = 0;
        let p2Score = 0;

        let p1Wave = { amp: 0, phase: 0, freq: 0.03 };
        let p2Wave = { amp: 0, phase: 0, freq: 0.05 };
        let bassLevel = 0, trebleLevel = 0;

        function makeColor(r, g, b) {
            return 0xFF000000 | (Math.floor(b) << 16) | (Math.floor(g) << 8) | Math.floor(r);
        }

        let colts = [];
        function resetMatch() {
            colts = [
                { x: -0.2, y: 0.2, vx: 0, vy: 0, hist: [] },
                { x: 0.2, y: -0.2, vx: 0, vy: 0, hist: [] }
            ];
            p1Score = 0, p2Score = 0, timeRemaining = MATCH_DURATION;
            matchStartTime = Date.now();
            gameState = 'PLAYING';
        }

        // --- Audio ---
        let audioCtx, analyser, dataArray;
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                document.getElementById('boot-seq').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('boot-seq').style.display = 'none';
                    resetMatch();
                    requestAnimationFrame(renderLoop);
                }, 1000);
            } catch (err) { alert("Mic access required."); }
        }
        document.getElementById('boot-seq').addEventListener('click', initAudio);

        // --- Interaction ---
        canvas.addEventListener('pointerdown', (e) => {
            if (gameState === 'BOOT') return;
            if (gameState === 'GAMEOVER') { resetMatch(); return; }
            const rect = canvas.getBoundingClientRect();
            const gx = Math.floor((e.clientX - rect.left) * (GRID_W / Math.max(1, rect.width)));
            const gy = Math.floor((e.clientY - rect.top) * (GRID_H / Math.max(1, rect.height)));

            // Lifted hitboxes to prevent browser UI blocking
            if (gy > GRID_H - 30) {
                if (gx < GRID_W / 2) {
                    geoMode = (geoMode + 1) % 3;
                } else {
                    if (gy < GRID_H - 15) gameRule = (gameRule + 1) % 2;
                    else visMode = (visMode + 1) % 2;
                }
            }
        });

        // --- Physics ---
        function getHyperbolicDistance(x, y) { return Math.sqrt(x*x + y*y); }

        function handlePocketEvent(index) {
            if (gameRule === 0) index === 0 ? p1Score++ : p2Score++;
            else index === 0 ? p2Score++ : p1Score++;
            
            // TELEPORT: Move to opposite side and nudge slightly inward to prevent re-collision
            colts[index].x = -colts[index].x * 0.9;
            colts[index].y = -colts[index].y * 0.9;
            colts[index].hist = [];
        }

        function updatePhysics() {
            if (gameState !== 'PLAYING') return;
            const elapsed = Math.floor((Date.now() - matchStartTime) / 1000);
            timeRemaining = Math.max(0, MATCH_DURATION - elapsed);
            if (timeRemaining === 0) { gameState = 'GAMEOVER'; return; }

            analyser.getByteFrequencyData(dataArray);
            let b = 0; for(let i=0; i<8; i++) b += dataArray[i]; bassLevel = (b/8)/255;
            let t = 0; for(let i=20; i<50; i++) t += dataArray[i]; trebleLevel = (t/30)/255;

            p1Wave.amp = bassLevel * 2.0;
            p2Wave.amp = trebleLevel * 2.0;
            p1Wave.phase += 0.02 + (bassLevel * 0.05);
            p2Wave.phase += 0.03 + (trebleLevel * 0.05);

            colts.forEach((c, index) => {
                const wave = index === 0 ? p1Wave : p2Wave;
                // HEAVY PHYSICS: Divided by 800 for high precision
                const fx = (wave.amp / 800) * Math.cos(wave.freq * globalTime + wave.phase);
                const fy = (wave.amp / 800) * Math.sin(wave.freq * globalTime + wave.phase * 1.1); 
                c.vx = (c.vx + fx) * 0.98; c.vy = (c.vy + fy) * 0.98;
                let nx = c.x + c.vx, ny = c.y + c.vy;
                const dist = getHyperbolicDistance(nx, ny);

                if (geoMode === 0) { // HYPER
                    if (dist > BOUNDARY_RADIUS) {
                        if (Math.abs(nx) > 0.50 && Math.abs(ny) > 0.50) { handlePocketEvent(index); return; }
                        const nX = nx/dist, nY = ny/dist, dot = c.vx*nX + c.vy*nY;
                        c.vx -= 2*dot*nX; c.vy -= 2*dot*nY; nx = nX*BOUNDARY_RADIUS; ny = nY*BOUNDARY_RADIUS;
                    }
                } else if (geoMode === 1) { // RECT
                    if (Math.abs(nx) > BOUNDARY_RADIUS || Math.abs(ny) > BOUNDARY_RADIUS) {
                        if (Math.abs(nx) > BOUNDARY_RADIUS - 0.15 && Math.abs(ny) > BOUNDARY_RADIUS - 0.15) { handlePocketEvent(index); return; }
                        if (Math.abs(nx) > BOUNDARY_RADIUS) { c.vx *= -1; nx = Math.sign(nx)*BOUNDARY_RADIUS; }
                        if (Math.abs(ny) > BOUNDARY_RADIUS) { c.vy *= -1; ny = Math.sign(ny)*BOUNDARY_RADIUS; }
                    }
                } else if (geoMode === 2) { // MORPH
                    const rad = BOUNDARY_RADIUS + Math.sin(globalTime * 0.05) * 0.05 + bassLevel * 0.1;
                    if (dist > rad) {
                        const theta = Math.atan2(ny, nx);
                        if (Math.abs(Math.sin(2 * theta + globalTime * 0.03)) > 0.9) { handlePocketEvent(index); return; }
                        const nX = nx/dist, nY = ny/dist, dot = c.vx*nX + c.vy*nY;
                        c.vx -= 2*dot*nX; c.vy -= 2*dot*nY; nx = nX*rad; ny = nY*rad;
                    }
                }
                c.x = nx; c.y = ny;
                c.hist.push({x: nx, y: ny});
                if (c.hist.length > 25) c.hist.shift();
            });
            globalTime++;
        }

        // --- Font ---
        const font = {
            'A':[0,1,0, 1,0,1, 1,1,1, 1,0,1, 1,0,1], 'B':[1,1,0, 1,0,1, 1,1,0, 1,0,1, 1,1,0],
            'C':[1,1,1, 1,0,0, 1,0,0, 1,0,0, 1,1,1], 'D':[1,1,0, 1,0,1, 1,0,1, 1,0,1, 1,1,0],
            'E':[1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,1,1], 'F':[1,1,1, 1,0,0, 1,1,0, 1,0,0, 1,0,0],
            'G':[0,1,1, 1,0,0, 1,0,1, 1,0,1, 0,1,1], 'H':[1,0,1, 1,0,1, 1,1,1, 1,0,1, 1,0,1],
            'I':[1,1,1, 0,1,0, 0,1,0, 0,1,0, 1,1,1], 'J':[0,0,1, 0,0,1, 0,0,1, 1,0,1, 0,1,0],
            'K':[1,0,1, 1,1,0, 1,0,0, 1,1,0, 1,0,1], 'L':[1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,1,1],
            'M':[1,0,1, 1,1,1, 1,0,1, 1,0,1, 1,0,1], 'N':[1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,0,1],
            'O':[1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], 'P':[1,1,1, 1,0,1, 1,1,1, 1,0,0, 1,0,0],
            'Q':[1,1,1, 1,0,1, 1,0,1, 1,1,1, 0,0,1], 'R':[1,1,1, 1,0,1, 1,1,0, 1,0,1, 1,0,1],
            'S':[1,1,1, 1,0,0, 1,1,1, 0,0,1, 1,1,1], 'T':[1,1,1, 0,1,0, 0,1,0, 0,1,0, 0,1,0],
            'U':[1,0,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], 'V':[1,0,1, 1,0,1, 1,0,1, 1,0,1, 0,1,0],
            'W':[1,0,1, 1,0,1, 1,0,1, 1,1,1, 1,0,1], 'X':[1,0,1, 1,0,1, 0,1,0, 1,0,1, 1,0,1],
            'Y':[1,0,1, 1,0,1, 0,1,0, 0,1,0, 0,1,0], 'Z':[1,1,1, 0,0,1, 0,1,0, 1,0,0, 1,1,1],
            '0':[1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1], '1':[0,1,0, 1,1,0, 0,1,0, 0,1,0, 1,1,1],
            '2':[1,1,1, 0,0,1, 1,1,1, 1,0,0, 1,1,1], '3':[1,1,1, 0,0,1, 1,1,1, 0,0,1, 1,1,1],
            '4':[1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1], '5':[1,1,1, 1,0,0, 1,1,1, 0,0,1, 1,1,1],
            '6':[1,1,1, 1,0,0, 1,1,1, 1,0,1, 1,1,1], '7':[1,1,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1],
            '8':[1,1,1, 1,0,1, 1,1,1, 1,0,1, 1,1,1], '9':[1,1,1, 1,0,1, 1,1,1, 0,0,1, 1,1,1],
            ':':[0,0,0, 0,1,0, 0,0,0, 0,1,0, 0,0,0], ' ':[0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0],
            '[':[1,1,0, 1,0,0, 1,0,0, 1,0,0, 1,1,0], ']':[0,1,1, 0,0,1, 0,0,1, 0,0,1, 0,1,1],
            '!':[0,1,0, 0,1,0, 0,1,0, 0,0,0, 0,1,0], '-':[0,0,0, 0,0,0, 1,1,1, 0,0,0, 0,0,0],
            '.':[0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,1,0], '/':[0,0,1, 0,0,1, 0,1,0, 1,0,0, 1,0,0]
        };

        function drawText(text, x, y, col, scale = 1) {
            let cx = x;
            for (let i=0; i<text.length; i++) {
                const glyph = font[text[i].toUpperCase()] || font[' '];
                for(let gy=0; gy<5; gy++) {
                    for(let gx=0; gx<3; gx++) {
                        if(glyph[gy*3+gx]) {
                            for(let sy=0; sy<scale; sy++) {
                                for(let sx=0; sx<scale; sx++) {
                                    const px = Math.floor(cx+(gx*scale)+sx), py = Math.floor(y+(gy*scale)+sy);
                                    if(px>=0 && px<GRID_W && py>=0 && py<GRID_H) buf[py*GRID_W+px] = col;
                                }
                            }
                        }
                    }
                }
                cx += (3*scale)+scale;
            }
        }

        // --- Render ---
        function renderLoop() {
            if(gameState === 'BOOT') return; updatePhysics();
            const t = globalTime * 0.05, minD = Math.min(GRID_W, GRID_H);
            const cW1 = makeColor(150+bassLevel*105, 0, 50+bassLevel*155), cW2 = makeColor(0, 100+trebleLevel*155, 150+trebleLevel*105), cI = makeColor(255-bassLevel*50, 100+trebleLevel*155, 0);
            const cP1 = 0xFFFFdd00, cP2 = 0xFFff00ff, cH = 0xFFaaffaa, cA = 0xFF0000FF, cO = (globalTime%30<15)?cH:makeColor(50,150,50);
            const cS1 = makeColor(255, 50, 200), cS2 = makeColor(50, 255, 100), cNB = makeColor(240, 200, 100);

            for (let i=0; i<buf.length; i++) {
                const gx = i%GRID_W, gy = Math.floor(i/GRID_W), nx = (gx-GRID_W/2)/(minD/2), ny = (gy-GRID_H/2)/(minD/2);
                let isB = false, isP = false, isOut = false, warp = 1, curR = BOUNDARY_RADIUS;

                if (geoMode === 0) {
                    if (getHyperbolicDistance(nx, ny) > BOUNDARY_RADIUS+0.02) isOut = true;
                    if (getHyperbolicDistance(nx, ny) > BOUNDARY_RADIUS-0.02 && getHyperbolicDistance(nx, ny) <= BOUNDARY_RADIUS+0.02) isB = true;
                    warp = 1/(1-Math.pow(Math.min(getHyperbolicDistance(nx,ny)/BOUNDARY_RADIUS, 0.99), 2)+0.1);
                    if (getHyperbolicDistance(nx,ny)>BOUNDARY_RADIUS-0.15 && Math.abs(nx)>0.5 && Math.abs(ny)>0.5) isP = true;
                } else if (geoMode === 1) {
                    if (Math.abs(nx)>BOUNDARY_RADIUS+0.02 || Math.abs(ny)>BOUNDARY_RADIUS+0.02) isOut = true;
                    if ((Math.abs(nx)>BOUNDARY_RADIUS-0.02 && Math.abs(nx)<=BOUNDARY_RADIUS+0.02 && Math.abs(ny)<=BOUNDARY_RADIUS+0.02) || (Math.abs(ny)>BOUNDARY_RADIUS-0.02 && Math.abs(ny)<=BOUNDARY_RADIUS+0.02 && Math.abs(nx)<=BOUNDARY_RADIUS+0.02)) isB = true;
                    warp = 1; if (Math.abs(nx)>BOUNDARY_RADIUS-0.15 && Math.abs(ny)>BOUNDARY_RADIUS-0.15 && Math.abs(nx)<=BOUNDARY_RADIUS && Math.abs(ny)<=BOUNDARY_RADIUS) isP = true;
                } else if (geoMode === 2) {
                    curR = BOUNDARY_RADIUS + Math.sin(t)*0.05 + bassLevel*0.1;
                    if (getHyperbolicDistance(nx, ny) > curR+0.02) isOut = true;
                    if (getHyperbolicDistance(nx, ny) > curR-0.02 && getHyperbolicDistance(nx, ny) <= curR+0.02) isB = true;
                    warp = 1/(1-Math.pow(Math.min(getHyperbolicDistance(nx,ny)/curR, 0.99), 2)+0.1);
                    if (getHyperbolicDistance(nx,ny)>curR-0.15 && getHyperbolicDistance(nx,ny)<=curR && Math.abs(Math.sin(2*Math.atan2(ny,nx)+globalTime*0.03))>0.9) isP = true;
                }

                let bgP = makeColor(30, 0, 20);
                if (isOut && !isB && !isP) {
                    const foam = Math.sin(getHyperbolicDistance(nx,ny)*15-t)*Math.cos(Math.atan2(ny,nx)*8+t*0.5);
                    bgP = foam>0.6?makeColor(20+bassLevel*30, 0, 40+trebleLevel*30):foam>0.2?makeColor(5, 15+bassLevel*15, 30):makeColor(2,2,5);
                } else if (isP) {
                    // VOID HOLE RENDERING: Deep black center with glowing edge
                    const swirl = Math.sin(nx*15+ny*15-t*3);
                    bgP = swirl>0.8?makeColor(120, 0, 100):makeColor(0,0,0);
                } else if (isB) { bgP = cW2; }
                else {
                    const gX = Math.abs(Math.sin(nx*15*warp)), gY = Math.abs(Math.sin(ny*15*warp));
                    if (gX<0.1 || gY<0.1) bgP = 0xFF111111;
                    else {
                        const inter = Math.abs(p1Wave.amp*Math.cos(12*warp*nx-t+p1Wave.phase) * p2Wave.amp*Math.sin(12*warp*ny+t+p2Wave.phase) + Math.sin((nx*nx+ny*ny)*12-t) + Math.sin(Math.atan2(ny,nx)*4+getHyperbolicDistance(nx,ny)*10-t*2)*0.5);
                        bgP = inter>0.8?cW2:inter>0.4?cI:inter>0.1?cW1:makeColor(30,0,20);
                    }
                }

                const distP1 = Math.pow(nx-colts[0].x,2)+Math.pow(ny-colts[0].y,2), distP2 = Math.pow(nx-colts[1].x,2)+Math.pow(ny-colts[1].y,2), isP1 = distP1<0.002, isP2 = distP2<0.002;
                if (visMode === 0) {
                    if (isP1) { buf[i]=cP1; continue; } if (isP2) { buf[i]=cP2; continue; }
                    let drawn=false;
                    for (let p of colts[0].hist) if(Math.pow(nx-p.x,2)+Math.pow(ny-p.y,2)<0.0005){buf[i]=cP1&0x77FFFFFF;drawn=true;break;} if(drawn)continue;
                    for (let p of colts[1].hist) if(Math.pow(nx-p.x,2)+Math.pow(ny-p.y,2)<0.0005){buf[i]=cP2&0x77FFFFFF;drawn=true;break;} if(drawn)continue;
                    buf[i] = bgP;
                } else {
                    const isS = (gy%4)<2, sC = isS?cS1:cS2, bgR=bgP&0xFF, bgG=(bgP>>8)&0xFF, bgB=(bgP>>16)&0xFF, sR=sC&0xFF, sG=(sC>>8)&0xFF, sB=(sC>>16)&0xFF;
                    if(isP1) buf[i]=isS?cS1:cNB; else if(isP2) buf[i]=!isS?cS2:cNB; else buf[i]=makeColor((bgR+sR)/2,(bgG+sG)/2,(bgB+sB)/2);
                }
            }

            drawText("P1:"+p1Score.toString().padStart(2,'0'), 8, 8, cP1); drawText("P2:"+p2Score.toString().padStart(2,'0'), Math.max(0,GRID_W-28), 8, cP2);
            drawText("T:"+timeRemaining.toString().padStart(2,'0'), Math.floor(GRID_W/2)-8, 8, (timeRemaining<=10?cA:cH));
            if (visMode === 1) { const bT = "BUYMEACOFFEE.COM/SUPPORT"; drawText(bT, Math.floor((GRID_W-bT.length*4)/2), 18, cH); }
            drawText("ONLINE:24MS", 8, Math.max(0,GRID_H-14), cO); drawText("GEO:"+(geoMode===0?"HYPER":geoMode===1?"RECT":"MORPH"), 8, Math.max(0,GRID_H-22), cH);
            drawText("MODE:"+(gameRule===0?"SINK":"SURV"), Math.max(0,GRID_W-46), Math.max(0,GRID_H-22), cH); drawText("VIS:"+(visMode===0?"NORM":"ILLUS"), Math.max(0,GRID_W-42), Math.max(0,GRID_H-14), cH);
            if (gameState === 'GAMEOVER') {
                for(let i=0; i<buf.length; i++) buf[i] = (buf[i]&0x44FFFFFF);
                const wT = p1Score>p2Score?"P1 WINS!":p2Score>p1Score?"P2 WINS!":"DRAW!", wC = p1Score>p2Score?cP1:p2Score>p1Score?cP2:cH;
                drawText(wT, Math.floor(GRID_W/2)-15, Math.floor(GRID_H/2)-10, wC); drawText("CLICK TO REMATCH", Math.floor(GRID_W/2)-31, Math.floor(GRID_H/2)+5, cH);
            }
            offCtx.putImageData(imgData, 0, 0); ctx.drawImage(offCanvas, 0, 0, canvas.width, canvas.height); requestAnimationFrame(renderLoop);
        }
    </script>
</body>
</html>